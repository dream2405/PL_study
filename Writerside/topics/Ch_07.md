# Expressions and Assignment Statements

## 산술식 (Arithmetic Expressions)
+ 프로그래밍 언어에서의 산술식 구성 요소
  + 연산자
  + 피연산자
  + 괄호
  + 함수 호출
+ 연산자의 종류
  + 단항
  + 이항
  + 삼항
+ 표기법
  + 중위 표기법: 대부분의 명령형 언어에서 사용
  + 전위 표기법

### 연산자 평가 순서
연산자 우선순위와 결합 규칙에 따라 평가 순서 결정
+ 우선순위
  + 연산자 우선순위 규칙: 서로 다른 우선순위 수준을 갖는 연산자들이 평가되는 순서
  + 덧셈과 뺄셈의 단항 버전
    + 단항 뺄셈: 그 연산자의 부호를 변경 (괄호 사용 필요)
      + 괄호가 없으면 적법하지 않음
+ 결합 규칙
  + 식이 동일한 수준의 우선순위를 가지면서 인접된 두개의 연산자를 포함할때, 어느 연산자가 먼저 평가되는가
  + 보통은 왼쪽부터 오른쪽 순서로 결합됨
    + 파이썬의 지수 연산자는 예외
    ```Python
    print(3 ** 2 ** 3)  # 10 ** (2 ** 3) 과 같음
    ```
  + 괄호
    + 프로그래머가 식에 괄호를 포함시켜 우선순위 규칙과 결합 규칙 변경 가능
  + 조건식
    + if-then-else 문이 조건식 배정문을 수행하는데 사용
    + C, Java에서는 삼항 연산자 가능
    ```C
    average = (count == 0) ? 0 : sum/count;
    ```
    + Python의 경우
    ```Python
    average = 0 if (count == 0) else sum/count
    ```

### 피연산자 평가 순서
어떤 연산자도 부작용을 갖지 않으면, 피연산자의 평가 순서는 무관   
따라서, 피연산자의 평가가 부작용을 가지는 경우에 대한 고려가 필요
+ 부작용
  + 함수의 부작용: 함수가 자신의 매개변수 중의 하나의 값이나 전역 변수의 값을 변경할때 발생
  + ex) a + fun(a)
    + fun()이 a를 변경하는 부작용을 갖지 않으면, a와 fun()의 평가 순서는 식의 값에 영향을 주지 않음
    + 그러나, fun()이 인수의 값을 변경한다면 순서에 따라 식의 값이 달라짐
  + 부작용의 문제에 대한 해결책
    + 함수적 부작용을 허용하지 않는 방법
      + 함수형 프로그래밍 언어에서는 함수적 부작용이 발생하지 않음
      + 명령형 언어에서는 변수가 존재하므로 힘듦
    + 엄격한 피연산자들의 평가 순서 정의
      + 컴파일러가 피연산자 평가 순서를 reordering하기도 함
      + 이를 금지해야 엄격한 순서 정의 가능
      + 따라서 실제 언어 설계에서는 힘듦
      + Java는 피연산자들이 왼쪽에서 오른쪽 순서로 평가되는 것을 강제
+ 참조 투명성과 부작용
  + 참조 투명성: 프로그램에서 동일한 값을 갖는 임의의 두개 식이 프로그램의 행동에 영향을 미치지 않으면서 임의의 위치에서 서로 다른 식으로 대체 가능
  + ex)
  ```C
  result1 = (fun(a) + b) / (fun(a) - c);
  // 위의 식을 아래로 대체 가능
  temp = fun(a);
  result2 = (temp + b) / (temp - c);
  ```
  + 함수 fun()이 부작용을 가지지 않는다면, result1과 result2의 값은 같음
  + 부작용은 그 코드가 나타내는 프로그램이 참조 투명성을 가지지 못하게 함

## 중복 연산자 (Overloaded Operations)
+ 한 연산자의 다중 사용  
+ 완전히 관련이 없는 두 개의 연산에 대해 동일한 기호를 사용하는 것은 판독성에 유해
+ 사용자 정의 중복: 프로그래머가 연산자 기호 중복하는 것을 허용

## 타입 변환
+ 축소 변환
  + 값을 그 원래 타입의 모든 값들의 근사치 값으로조차 저장할 수 없는 타입으로 변환
  + 축소 변환은 항상 불안정
+ 확장 변환
  + 값을 적어도 그 원래 타입의 모든 값들의 근사치를 포함할 수 있는 타입으로 변환
  + 거의 안전
+ 타입 변환은 명시적이거나 묵시적

### 식의 타입 강제 변환
+ 혼합형 식
  + 하나의 연산자가 서로 다른 타입의 피연산자를 가지는 식
  + 묵시적 피연산자 타입 변환 컴파일러에 의해 수행
  + 대부분의 언어에서 혼합형 산술식에 대한 제약 없음
+ 명시적 타입 변환
  + 대부분의 언어에서 확장/축소 변환 모두에 대하여 명시적 타입 변환 제공
  + 어떤 경우엔 경고 메시지 생성 가능
  + 흔히 캐스트라고 부름

## 관계식과 불리안 식
+ 관계식
  + 두개의 피연산자와 한개의 관계 연산자로 구성
    + 두개의 피연산자의 값을 비교
  + 관계식의 결과 값은 불리안 값
    + C언어에서는 수치 값
  + 동등과 비동등에 대한 관계 연산자
    + 프로그래밍 언어에 따라 다름
    + 새로운 관계 연산자
      + JavaScript와 PH는 "==="와 "!==" 추가 지원
        + 강제 변환을 허용하지 않는 관게 연산자
+ 불리안 식
  + 불리안 변수, 불리안 상수, 관계식, 불리안 연산자들로 구성
  + 불리안 연산자
    + AND, OR, NOT, XOR 등등
    + 불리안 대수의 수학에서 AND와 OR은 동일한 우선순위
      + 하지만 C, Java 등에서는 OR보다 AND가 높은 우선순위
  + C언어에서의 불리안 식
    + a > b > c 의 경우, 좌결합이기 때문에 a > b가 1혹은 0이 되어 b와 c의 비교 실행되지 않음

## Short-Circuit Evaluation
+ 식의 결과가 모든 피연산자와 연산자를 평가하지 않고서 결정되는 평가
+ 불리안 식에서 비 단락회로 평가가 갖는 문제점
  + 두 개의 관계식이 첫 번째 관계식의 값에 관계없이 모두 평가
  + out-of-range 예외 발생 가능성
+ 단락회로 평가에 의해 발생 가능한 문제점
  + 실행 중에 프로그래머가 평가 될때마다 둘다 실행된다고 가정하면 오류 초래 가능성
+ C, Java에서 &&와 ||는 모두 단락회로
+ Python에서 모든 논리적 연산자는 단락회로

## 배정문
+ 사용자가 변수에 대한 값의 바인딩을 동적으로 변경시킬 수 있는 메커니즘 제공
+ 단순 배정문
  + 대부분의 언어에서 "=" 사용
+ 복합 배정 연산자
  + C, Java, Python의 "+="
+ 단항 배정 연산자
  + C, Java, Javascript 등이 2개의 특정 단항 산술 연산자 제공
   + "++", "--"
   + 이들은 전위 연산자, 후위 연산자로 나타날 수 있음
   + 두 개의 단항 연산자가 동일한 피연산자에 적용될때 결합 순서는 오른쪽 부터 왼쪽임에 유의
+ 식으로서의 배정문
  + C, Java 등에서, 배정문은 결과를 생성
  + 목적지에 할당되는 값과 동일
  + 배정문은 식으로써 그리고 다른 식에 포함된 피연산자로서 사용될 수 있음
  + 배정 연산자는 다른 이항 연산자와 매우 유사
    + 단, 배정 연산자는 왼쪽 피연산자를 변경하는 부작용을 가짐
  + 관계 연산자가 배정 연산자보다 우선순위가 높음에 유의!!
  + 단점
    + 읽고 이해하기 어려운 식을 초래
    + 다중 목적지 배정
      + a = b = c = 0;
      + 파이썬에서도 가능
    + if (a = b) - 자바에서는 불가능하지만 c언어에서는 가능
+ 타입 강제 변환 규칙
  + C/C++에서 확장이든 축소든 관계없이 사용 가능
  + Java에서는 확장인 경우에만 타입 강제 변환 사용